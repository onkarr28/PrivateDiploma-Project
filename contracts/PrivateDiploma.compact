// PrivateDiploma.compact
// Privacy-Preserving Educational Credential Verification System
// Built on Midnight Network using Zero-Knowledge Proofs

import "../std/collections/map"
import "../std/collections/set"
import "../std/debug"

// ============================================================================
// DATA STRUCTURES
// ============================================================================

// Represents a diploma certificate with privacy preservation
// The actual student details (name, grades) are hashed and stored privately
struct DiplomaRecord {
    // Public: Hash of the diploma (university + student ID + timestamp)
    certificateHash: Field,
    
    // Public: The issuing university address
    issuerAddress: Address,
    
    // Public: Timestamp when diploma was issued (for validity checking)
    issuanceTimestamp: Field,
    
    // Public: Diploma status (0 = revoked, 1 = valid)
    status: Field,
    
    // Public: Hash of student's private data (name + ID + marks)
    // This is a commitment, not the actual data
    studentDataCommitment: Field,
    
    // Public: Degree type hash (CS, Engineering, etc.)
    degreeTypeHash: Field,
    
    // Public: University department identifier hash
    departmentHash: Field
}

// Structure for diploma verification query
struct VerificationProof {
    // The certificate hash being verified
    certificateHash: Field,
    
    // Zero-knowledge proof commitment
    // This proves student has valid diploma without revealing identity
    proofCommitment: Field,
    
    // Nullifier (prevents double-spending of the same diploma)
    nullifier: Field,
    
    // Random nonce for proof uniqueness
    nonce: Field
}

// ============================================================================
// CONTRACT STATE
// ============================================================================

contract PrivateDiploma {
    
    // Public ledger: maps certificateHash -> DiplomaRecord
    // All stored data is public, but sensitive student info is hashed
    let diplomaLedger: Map<Field, DiplomaRecord>
    
    // Authorized university addresses that can issue diplomas
    let authorizedIssuers: Set<Address>
    
    // Nullifier set: tracks which verification proofs have been used
    // Prevents the same proof from being used multiple times
    let usedNullifiers: Set<Field>
    
    // Contract owner/admin address
    let contractOwner: Address
    
    // Diploma validity window (in seconds)
    let diplomaValidityPeriod: Field
    
    // ========================================================================
    // INITIALIZATION
    // ========================================================================
    
    fn new(initialOwner: Address, validityPeriod: Field) {
        contractOwner = initialOwner
        diplomaValidityPeriod = validityPeriod
        authorizedIssuers = Set::new()
        usedNullifiers = Set::new()
        diplomaLedger = Map::new()
    }
    
    // ========================================================================
    // ADMIN FUNCTIONS (Restricted to contract owner)
    // ========================================================================
    
    /**
     * Add a university address to the list of authorized issuers
     * Only the contract owner can call this function
     * 
     * @param university: The address of the university to authorize
     */
    fn addAuthorizedIssuer(university: Address) {
        // Verify caller is contract owner
        assert tx.sender == contractOwner
        
        // Add university to authorized issuers set
        authorizedIssuers.insert(university)
    }
    
    /**
     * Remove a university from authorized issuers
     * Only the contract owner can call this function
     * 
     * @param university: The address of the university to revoke
     */
    fn removeAuthorizedIssuer(university: Address) {
        assert tx.sender == contractOwner
        authorizedIssuers.remove(university)
    }
    
    // ========================================================================
    // CORE DIPLOMA ISSUANCE FUNCTION
    // ========================================================================
    
    /**
     * issueDiploma: Issues a diploma on-chain with privacy preservation
     * 
     * PRIVACY GUARANTEE:
     * - Student's actual name and grades are NOT stored on-chain
     * - Only a cryptographic hash commitment of student data is stored
     * - The university issues a diploma proof that can be verified offline
     * 
     * @param certificateHash: Hash(universityID + studentID + timestamp)
     * @param studentDataCommitment: Hash(studentName + studentMarks + metadata)
     * @param degreeTypeHash: Hash of degree type (e.g., "Computer Science")
     * @param departmentHash: Hash of issuing department
     * @param issuanceTimestamp: Unix timestamp of issue date
     */
    fn issueDiploma(
        certificateHash: Field,
        studentDataCommitment: Field,
        degreeTypeHash: Field,
        departmentHash: Field,
        issuanceTimestamp: Field
    ) {
        // SECURITY CHECK: Only authorized universities can issue diplomas
        assert authorizedIssuers.contains(tx.sender)
        
        // SECURITY CHECK: Prevent duplicate diploma issuance
        assert !diplomaLedger.contains(certificateHash)
        
        // SECURITY CHECK: Timestamp should not be in the future
        assert issuanceTimestamp <= tx.blocknumber
        
        // Create diploma record
        let diploma = DiplomaRecord {
            certificateHash: certificateHash,
            issuerAddress: tx.sender,
            issuanceTimestamp: issuanceTimestamp,
            status: 1,  // 1 = valid, 0 = revoked
            studentDataCommitment: studentDataCommitment,
            degreeTypeHash: degreeTypeHash,
            departmentHash: departmentHash
        }
        
        // Store on public ledger
        diplomaLedger.insert(certificateHash, diploma)
        
        // Emit event (for off-chain indexing)
        // Event: DiplomaIssued(certificateHash, issuerAddress, timestamp)
    }
    
    // ========================================================================
    // DIPLOMA REVOCATION
    // ========================================================================
    
    /**
     * revokeDiploma: Revokes a diploma (e.g., for academic misconduct)
     * Only the issuing university can revoke their own diplomas
     * 
     * @param certificateHash: The certificate to revoke
     */
    fn revokeDiploma(certificateHash: Field) {
        // Get diploma from ledger
        let diploma = diplomaLedger.get(certificateHash)
        assert diploma != null
        
        // Only the issuing university can revoke
        assert diploma.issuerAddress == tx.sender
        
        // Mark as revoked
        diploma.status = 0
        diplomaLedger.insert(certificateHash, diploma)
    }
    
    // ========================================================================
    // ZERO-KNOWLEDGE VERIFICATION (PRIVATE)
    // ========================================================================
    
    /**
     * verifyDegree: Private verification function for ZKP validation
     * 
     * Student uses this function to prove they have a valid diploma
     * WITHOUT revealing their identity or marks to the verifier.
     * 
     * This function checks:
     * 1. Certificate exists and is valid
     * 2. Diploma hasn't been revoked
     * 3. Diploma is within validity period
     * 4. ZKP proof is valid (proof commitment matches ledger commitment)
     * 5. Nullifier hasn't been used before (prevents replay attacks)
     * 
     * BLOCKCHAIN PRIVACY:
     * - This function is marked 'private' - its execution doesn't reveal details
     * - Only the zero-knowledge proof is verified against ledger state
     * - Student identity remains hidden from the verifier
     * 
     * @param proof: The zero-knowledge proof structure
     * @return: true if diploma is valid, false otherwise
     */
    private fn verifyDegree(proof: VerificationProof) -> bool {
        // Step 1: Verify certificate exists
        assert diplomaLedger.contains(proof.certificateHash)
        
        // Step 2: Retrieve diploma record
        let diploma = diplomaLedger.get(proof.certificateHash)
        
        // Step 3: Check diploma is valid (not revoked)
        assert diploma.status == 1
        
        // Step 4: Check diploma is within validity period
        let currentTime = tx.blocknumber
        let diplomaAge = currentTime - diploma.issuanceTimestamp
        assert diplomaAge <= diplomaValidityPeriod
        
        // Step 5: Verify ZKP proof validity
        // The proof commitment should match the student data commitment
        // This is where the zero-knowledge magic happens
        assert proof.proofCommitment == diploma.studentDataCommitment
        
        // Step 6: Check nullifier hasn't been used (prevent double-spending)
        assert !usedNullifiers.contains(proof.nullifier)
        
        // Step 7: Add nullifier to used set (mark as consumed)
        usedNullifiers.insert(proof.nullifier)
        
        return true
    }
    
    /**
     * submitVerificationProof: Public entry point for submitting ZKP
     * 
     * When employer/verifier calls this, the verification happens
     * using the private verifyDegree function. The actual student
     * identity never needs to be revealed.
     * 
     * @param proof: The zero-knowledge proof from the student
     * @return: true if diploma is valid and proof is verified
     */
    fn submitVerificationProof(proof: VerificationProof) -> bool {
        // Call private verification function
        return verifyDegree(proof)
    }
    
    // ========================================================================
    // QUERY FUNCTIONS (Read-only, for verification)
    // ========================================================================
    
    /**
     * getDiplomaStatus: Check if a diploma exists and is valid
     * Public function - reveals only status, not student identity
     * 
     * @param certificateHash: The certificate hash to check
     * @return: 1 if valid, 0 if revoked, null if doesn't exist
     */
    fn getDiplomaStatus(certificateHash: Field) -> Field {
        if diplomaLedger.contains(certificateHash) {
            let diploma = diplomaLedger.get(certificateHash)
            return diploma.status
        }
        return 0
    }
    
    /**
     * verifyIssuanceAuthority: Check if an address is authorized to issue
     * 
     * @param address: The address to verify
     * @return: true if address is authorized issuer
     */
    fn verifyIssuanceAuthority(address: Address) -> bool {
        return authorizedIssuers.contains(address)
    }
    
    /**
     * checkDiplomaValidity: Check if diploma is within validity period
     * 
     * @param certificateHash: The certificate to check
     * @return: true if diploma is still valid
     */
    fn checkDiplomaValidity(certificateHash: Field) -> bool {
        if !diplomaLedger.contains(certificateHash) {
            return false
        }
        
        let diploma = diplomaLedger.get(certificateHash)
        
        // Check if revoked
        if diploma.status == 0 {
            return false
        }
        
        // Check if within validity period
        let currentTime = tx.blocknumber
        let diplomaAge = currentTime - diploma.issuanceTimestamp
        
        return diplomaAge <= diplomaValidityPeriod
    }
    
    /**
     * isNullifierUsed: Check if a nullifier has been used (replay protection)
     * 
     * @param nullifier: The nullifier to check
     * @return: true if nullifier has been used
     */
    fn isNullifierUsed(nullifier: Field) -> bool {
        return usedNullifiers.contains(nullifier)
    }
}

// ============================================================================
// PRIVACY GUARANTEES SUMMARY
// ============================================================================
/*
 * WHAT STAYS PRIVATE:
 * - Student name: Only stored as hash(name) in studentDataCommitment
 * - Student grades/marks: Only stored as hash in studentDataCommitment
 * - Student ID: Only stored as hash in certificateHash
 * - Academic transcript: Never exposed on-chain
 * 
 * WHAT'S PUBLIC:
 * - Certificate hash: Identifies diploma uniquely
 * - Issuer address: Which university issued it
 * - Issuance timestamp: When diploma was issued
 * - Diploma status: Valid or revoked
 * - Student data commitment: Hash (not the data itself)
 * - Degree type hash: What degree (hashed)
 * - Department hash: Which department (hashed)
 * 
 * VERIFICATION FLOW:
 * 1. Student creates zero-knowledge proof offline (no blockchain needed)
 * 2. Student sends proof to employer/verifier
 * 3. Verifier calls submitVerificationProof() with the proof
 * 4. Smart contract verifies proof without learning student identity
 * 5. Verifier learns only: "This diploma is valid" (no personal data)
 * 
 * SECURITY FEATURES:
 * - Only authorized universities can issue diplomas
 * - Diplomas can't be duplicated
 * - Universities can revoke diplomas (misconduct, errors)
 * - Validity period prevents old diplomas from being used
 * - Nullifier prevents same proof from being used multiple times
 */
